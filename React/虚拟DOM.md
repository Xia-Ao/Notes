
## 为什么使用虚拟DOM
浏览器是解析HTML先生成一个DOM树，后面生成CSSOM树，合并成Render树，然后进行布局，回流重绘操作，如果频繁的DOM操作，会不断的带来浏览器的回流与重绘，当然，浏览器也不会那么的傻，会有各种优化来进行DOM操作，但是还是不推荐频繁的DOM操作，使用虚拟DOM，通过JS来操作对象，因为JS的性能比较好，性能上面优于真是DOM。

## DOM算法
虚拟DOM的改变怎么判断，与之前的DOM的进行比较，使用什么算法时间复杂度和空间复杂度都比较合适？

Virtual DOM 的步骤
1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
3. 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了


### diff算法
两棵树如果完全比较时间复杂度是O(n^3)，但参照《深入浅出React和Redux》一书中的介绍，React的Diff算法的时间复杂度是O(n)。要实现这么低的时间复杂度，意味着只能平层地比较两棵树的节点，放弃了深度遍历。这样做，似乎牺牲了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层级移动DOM元素，所以这样做是最优的。

### 其他算法

### key值
在移动、增加、删除节点时，简单粗暴的方法就是先卸载，再装载，直到实现目标，效率极低，如果我们在遍历的加上key值，根据key找到具体的位置进行操作，这样效率较高

## 参考

[虚拟DOM介绍](https://www.jianshu.com/p/616999666920)
[深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)

