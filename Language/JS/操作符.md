# JS容易出现误区的操作符

## `typeof`

`typeof`操作符返回一个字符串，表示未经计算的操作数的类型。

- `typeof`运算符，判断数据类型，对于基本类型，返回基本类型，对于引用类型的，不管哪一种引用类型，都返回`'object'`
- `typeof` 除了`null` 返回`'object'`，和函数返回`'function'`，其他都能正确返回，凡是引用类型返回都是`'object'`。

### `typeof`对`new`一个构造函数生成内容的判断需要特别注意
```js
var str = new String('String');
var num = new Number(100);

typeof str; // 返回 'object'
typeof num; // 返回 'object'

var func = new Function();

typeof func; // 返回 'function'
```
因此，通过`typeof`判断基本数据类型，也会返回不一样的结果，需要特别注意，在不确定是否是基本数据类型的场景下慎用，不过大部分场景中很少存在通过构造函数生成基本数据类型，可以使用`typeof`判断。


## 对象实例判断运算符

### `instanceof`

`instanceof`运算符用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。

这里有一篇[博文](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html)，详细介绍的instanceof运算符的历史由来以及定义

`instanceof` 运算符通常用来判断一个实例是否属于某种类型，使用方法为`foo instanceof Foo`返回一个`Boolean`值,因为这个原因，更多的时候在继承关系中，用来判断**实例是否属于一个父类型**。

`instanceof`如何实现这样的功能，语言规范里面有详细的介绍，这里截取js表达的方式

```js
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
     var O = R.prototype;// 取 R 的显示原型
     L = L.__proto__;// 取 L 的隐式原型
     while (true) {
         if (L === null)
             return false;
         if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
             return true;
         L = L.__proto__;
     }
 }
```

由规范得到，`instanceof`将前面表达式的`__proto__`与后面的表达式的`prototype`进行严格相等`===`比较
- 如果相等返回true，
- 如果不相等，则继续循环获取前面表达式的`__proto__`，直到 `Object.__proto__===null`为止返回false。

![](/assets/prototype.jpg)

```js
console.log(Object instanceof Object);//true 
console.log(Function instanceof Function);//true 
console.log(Number instanceof Number);//false 
console.log(String instanceof String);//false 

console.log(Function instanceof Object);//true 

console.log(Foo instanceof Function);//true 
console.log(Foo instanceof Foo);//false
```



### `in`

### ``
### `typeof` vs `Object.prototype.toString.call()` 判断类型



**`Object.prototype.toString.call()`**

返回一个类似 `[Object Type]`的字符串

## delete
`delete`用于删除某个对象的属性，`delete` 操作符会从某个对象上移除指定属性。和释放内存无关。
- 如果删除属性的该对象原型链上有同名属性，delete只会删除自身属性，删除之后，对象会使用原型链上的属性。
- 任何用`let`或`const`声明的属性不能够从它被声明的作用域中删除
- 使用`var`声明的属性不能从全局作用域中或者函数作用域中删除
- 不可设置的属性不能被删除

### delete与splice区别
以数组对象为例:
1. `delete`只能删除指定数组元素的对象，数组的大小不改变，删除后位置空余，显示`undefined`，或者其他填充值。`splice`指定删除数组元素对象，数组大小发生变化。
2. `delete`每次只能删除一个，`splice`一次可以删除一个或多个。


### `new`做了什么
```js
// 正常创建一个对象
function Super() {};
var s = new Super();
```
new在上述过程中的操作科分为三步
```js
var s = {};
s.__proto__ = Super.prototype;
Super.call(s);
// 其中，第一步和第二步可以理解为Object.create(Super.prototype)
```

### 重点关注，有可能你就踩坑了
#### Numbe中ToNumber隐式方法

```js
Number('')  // 0
Number('a123')  //NaN
```

| input     | result                                     |
|:----------:|:-------------------------------------------|
| null      | +0                                         |
| undefined | NaN                                        |
| Boolean   | +0 / 1                                     |
| Number    | 不转换                                      |
| String    |                                            |
| Symbol    | 报错                                       |
| Object    | ToNumber(ToPrimitive( input , Number)) |

#### `ToPrimitive()`隐式装箱

关于隐式转换参考这篇文章：[js隐式装箱-ToPrimitive](https://sinaad.github.io/xfe/2016/04/15/ToPrimitive/)

默认用法：
```js
ToPrimitive(input [,PreferredType])，（ToPrimitive方法可被修改）
```
- 如果是Date对象求原值，则PreferredType是String，其他均为Number。
- PreferredType是String，则先调用toString()，结果不是原始值的话再调用valueOf()，还不是原始值的话则抛出错误；
- PreferredType是Number，则先调用valueOf()再调用toString()。
- 总结来讲就是：如果是对`Date`对象做隐式转化，先调用`toString`, 如果不是原始值的话，调用`valueOf()`，还不是原始值的话则抛出错误; 对其他对象做隐式转化的话，则先调用`valueOf()`再调用`toString()`。


#### 为什么0.1+ 0.2 != 0.3
在JS中,采用的是双精度版本（64位），十进制的数都是使用二进制表示的，0.1在二进制中表示为
```js
0.1 = 2^-4 * 1.10011(0011)  // (0011) 表示循环
```
所以0.1表示的二进制与0.2表示的二进制相加，在转化为十进制就变成了`0.30000000000000004`。

解决方案：`parseFloat((0.1 + 0.2).toFixed(10))`


#### 给基本类型数据添加属性，不报错，但取值时是undefined

```js
var a = 10;
a.pro = 10;
console.log(a.pro + a);  //undefined
var s = 'hello';
s.pro = 'world';
console.log(s.pro + s);  //'undefinedhello'
```
a.pro和s.pro都为undefined。给基本类型数据加属性不报错，但是引用的话返回undefined，10+undefined返回NaN，而undefined和string相加时转变成了字符串。




