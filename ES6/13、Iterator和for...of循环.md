# Iterator 与for of 循环

## Iterator遍历器
Iterator 的遍历过程是这样的。

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

（2）第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。

（3）第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。


对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。

### 调用Iterator接口的场合
**（1）解构赋值**

对数组和 Set 结构进行解构赋值时，会默认调用`Symbol.iterator`方法。

**（2）扩展运算符**

扩展运算符（...）也会调用默认的 Iterator 接口。

**（3）yield***

`yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。

**（4）其他场合**

由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。
* for...of
* Array.from()
* Map(), Set(), WeakMap(), WeakSet()（比如`new Map([['a',1],['b',2]])`）
* Promise.all()
* Promise.race()


### 遍历器对象的 return()，throw()

遍历器对象除了具有`next`方法，还可以具有`return`方法和`throw`方法。如果你自己写遍历器对象生成函数，那么`next`方法是必须部署的，`return`方法和`throw`方法是否部署是可选的。

`return`方法的使用场合是，如果`for...of`循环提前退出（通常是因为出错，或者有`break`语句），就会调用`return`方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署`return`方法。

**`return`方法必须返回一个对象**，这是 Generator 规格决定的。


## for of
遍历具有iterator接口的对象，对于普通对象，不能直接使用for of 只有部署了iterator接口才行，但是可以使用 for in遍历。

for in与 for of对比

`for...in`循环有几个缺点。
* 数组的键名是数字，但是`for...in`循环是以字符串作为键名"0"、"1"、"2"等等。
* `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
* 某些情况下，`for...in`循环会以任意顺序遍历键名。

总之，`for...in`循环主要是为遍历对象而设计的，不适用于遍历数组。

for of
* 有着同`for...in`一样的简洁语法，但是没有`for...in`那些缺点。
* 不同于`forEach`方法，它可以与`break`、`continue`和`return`配合使用。
* 提供了遍历所有数据结构的统一操作接口。
